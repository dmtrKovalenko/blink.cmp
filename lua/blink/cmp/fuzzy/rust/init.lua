--- @return string
local function get_lib_extension()
  if jit.os:lower() == 'mac' or jit.os:lower() == 'osx' then return '.dylib' end
  if jit.os:lower() == 'windows' then return '.dll' end
  return '.so'
end

-- search for the lib in the /target/release directory with and without the lib prefix
-- since MSVC doesn't include the prefix
local info = debug.getinfo(1, 'S')
local base_path = info and info.source and info.source:match('@?(.*/)') or ''

-- Fallback: if base_path is nil, try to determine from current file path
if not base_path or base_path == '' then
  base_path = vim.fn.fnamemodify(vim.fn.resolve(vim.fn.expand('<sfile>:p')), ':h') .. '/'
end

local paths = {
  base_path .. '../../../../../target/release/libblink_cmp_fuzzy' .. get_lib_extension(),
  base_path .. '../../../../../target/release/blink_cmp_fuzzy' .. get_lib_extension(),
}

local cargo_target_dir = os.getenv('CARGO_TARGET_DIR')
if cargo_target_dir then
  table.insert(paths, cargo_target_dir .. '/release/libblink_cmp_fuzzy' .. get_lib_extension())
  table.insert(paths, cargo_target_dir .. '/release/blink_cmp_fuzzy' .. get_lib_extension())
end

-- this is done to not depnd on cpath if many different libraries are used
-- as cpath is global across all the plugins. Find first valid path and load that.
local function try_load_library()
  for _, actual_path in ipairs(paths) do
    local stat = vim.uv.fs_stat(actual_path)
    if stat and stat.type == 'file' then
      -- lua_open_<modulename> is the conventioned symbol name for lua
      -- automatically generated by mlua bindings
      local loader, err = package.loadlib(actual_path, 'luaopen_blink_cmp_fuzzy')
      if err then return nil, err end

      if loader then return loader() end
    end
  end
  return nil, 'No valid library found in any search path'
end

local backend, load_err = try_load_library()
if not backend then
  local err_msg = string.format(
    'Failed to load blink.cmp rust backend.\nError: %s\nSearched paths:\n%s\nMake sure binary downloaded or built with `cargo build --release`',
    tostring(load_err),
    vim.inspect(paths)
  )
  error(err_msg)
end

return backend
